package analysis.pointer.graph;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ConcurrentMap;

import analysis.AnalysisUtil;
import analysis.pointer.analyses.AString;
import analysis.pointer.analyses.ReflectiveHAF;

public class StringConstraints {

    private final ConcurrentMap<StringVariableReplica, AString> map;
    private final ReflectiveHAF haf;
    private final AString initialString;
    private final Set<StringVariableReplica> active;
    private final ConcurrentMap<StringVariableReplica, Set<StringVariableReplica>> dependsOn;

    /* Factory Methods */

    public static StringConstraints make(ReflectiveHAF haf) {
        return new StringConstraints(haf);
    }

    /* Constructors */

    private StringConstraints(ReflectiveHAF haf) {
        this.haf = haf;
        this.initialString = haf.getAStringSet(Collections.singleton(""));
        this.map = AnalysisUtil.createConcurrentHashMap();
        this.active = AnalysisUtil.createConcurrentSet();
        this.dependsOn = AnalysisUtil.createConcurrentHashMap();
    }

    /* Logic */

    public AString getAStringFor(StringVariableReplica svr) {
        AString shat = this.map.get(svr);
        return shat == null ? haf.getAStringBottom() : shat;
    }

    public StringConstraintDelta joinAt(StringVariableReplica svr, AString shat) {
        if (svr.toString().contains("LSV 69_0")) {
            System.err.println("[joinAt] " + svr + " `join` " + shat);
        }

        if (this.active.contains(svr)) {
            if (this.map.containsKey(svr)) {
                if (svr.toString().contains("LSV 69_0")) {
                    System.err.println("[joinAt] before " + svr + " = " + this.map.get(svr));
                }
                boolean changedp = this.map.get(svr).join(shat);
                if (svr.toString().contains("LSV 69_0")) {
                    System.err.println("[joinAt] after " + svr + " = " + this.map.get(svr));
                    System.err.println("[joinAt] changed = " + changedp);
                }
                return changedp ? StringConstraintDelta.make(this, svr) : StringConstraintDelta.makeEmpty(this);
            }
            else {
                if (svr.toString().contains("LSV 69_0")) {
                    System.err.println("[joinAt] nothing in 69_0 yet, setting to copy of " + shat);
                }
                this.map.put(svr, shat.copy());
                return StringConstraintDelta.make(this, svr);
            }
        }
        else {
            return StringConstraintDelta.makeEmpty(this);
        }
    }

    public StringConstraintDelta upperBounds(StringVariableReplica svr1, StringVariableReplica svr2) {
        if (this.active.contains(svr1)) {
            if (this.map.containsKey(svr2)) {
                return this.joinAt(svr1, this.map.get(svr2));
            }
            else {
                return StringConstraintDelta.makeEmpty(this);
            }
        }
        else {
            return StringConstraintDelta.makeEmpty(this);
        }
    }

    public void recordDependency(StringVariableReplica x, StringVariableReplica y) {
        if (this.dependsOn.containsKey(x)) {
            this.dependsOn.get(x).add(y);
        }
        else {
            this.dependsOn.put(x, AnalysisUtil.createConcurrentSingletonSet(y));
        }
    }

    public StringConstraintDelta activate(StringVariableReplica x) {
        System.err.println("[activate] Activating: " + x);
        return this.active.contains(x) ? StringConstraintDelta.makeEmpty(this)
                : StringConstraintDelta.make(this, activateAndGetSources(x));
    }

    private Set<StringVariableReplica> activateAndGetSources(StringVariableReplica x) {
        this.active.add(x);

        System.err.println("[activateAndGetSources] Activating: " + x);

        if (this.dependsOn.containsKey(x) && !this.dependsOn.get(x).isEmpty()) {
            Set<StringVariableReplica> sources = new HashSet<>();
            for (StringVariableReplica y : this.dependsOn.get(x)) {
                sources.addAll(activateAndGetSources(y));
            }
            return sources;
        }
        else {
            return Collections.singleton(x);
        }
    }

    /*
     * AUTOGENERATED STUFF
     *
     * Be sure to regenerate these (using Eclipse) if you change the number of fields in this class
     *
     * DEFINTIELY DONT CHANGE ANYTHING
     */

    @Override
    public String toString() {
        return "StringConstraints [map=" + map + "]";
    }

}
