Any particular reason edges live in the nodes in the Flowgraph?
A: not really

Do I have to iterate through SCCs or can I use a single workqueue instead?
A: Yes its better, do the simple way first

I don't really like the WALA CFG for data-flow. It is over basic blocks so no generated exceptions from instructions
A: It actual does the right thing apparently

For a data-flow analysis with side effects (e.g. printing) do I have to keep a set of visited nodes, this seems a bit hackish, but to avoid duplicates it might be unavoidable (we don't want to reanalyze).
A: its not really a data-flow

Should null data-flow items be allowed? Should they be propagated?
Polyglot says yes for the first and no for the second
A: decide and go with it, could create default item, createInitialItem(Edge)

Do I actually need a lattice and confluence or should I let the individual analysis decide how to compute the meet of the incoming edges (if they even need to).
A: Add back in predecessor to Set of input flow items, look at book

Do we actually need to hashcons the varcontexts?
A: Performance

Widen is never not the same as upperbound.
A: Widen

Do I need to handle IllegalMonitorStateExceptions for return statements
A: Skip it

How about WrongMethodTypeException for virtual methods
A: check the method name and add it

TODO Priority Queue for interproc?
DONE: Need overview interprocedural manager
DONE: Is sound result
TODO Reasoning about read and write sets

TODO Need to rework exceptions in statement registrar. instead of check thrown add a statement localToLocal for each catch block and the exit with filtered results.

TODO need to add in call graph edges for the class initializers in the appropriate places, I guess this should happen for each instruction that could add a class init in "process". For now lets just do them all up front, otherwise it gets messy to determine which clinits need to be called when. e.g. a class might be initialized on one branch of an "if" and not on the other, so it still needs to be initialized again if it appears after the "phi".

Do I need exception in VarContext if there is a local for the exception, the local is what I use in the pointer analysis, probably should use it here too.

WALA-BUG: getLastInstructionIndex() on ISSABasic block delegates to the Shrike BB, but instruction at some indices are removed in translation, so this instruction might be null (and getLastInstruction() returns null).

WALA-BUG: Using methods from AbstractNumberedGraph in BasicCallGraph breaks the abstraction barrier (for example addNode bipasses the memoization of findOrCreateNode). This should be a delegation relationship not inheritance.

PDG: Do I need to create extra edges in the PDG for clarity? Could make this an option or something. Maybe significantly smaller PDGs (i.e. don't create a node for a + b and a copy edge to c, but instead create edges from a to c and b to c.)

TODO check if mergeAndCreateMap can be used in place of factToMap in some places

TODO register pointer statements for instructions that throw generated exceptions even if they are primitive operations

what are we losing in the PDG by not having a PC and value for each exception type this could throw? Some edges from the call-site can only carry certain types so we could be more precise there (as we would be in Accrue)

loadMetadata: This can throw a ClassNotFoundException, but this could be known
statically if all the class files were known so it doesn't affect the PDG

WALA-BUG: By default the fake root method has no return statement so it had normal and exception edges from a basic block to the exit block.

TODO should we add a PC for the call program point in the caller, what could that help?